# if 표현식
## 명령형 언어 스타일
```java
var filename = "default.txt"
  if (!args.isEmpty)
    filename = args(0)
```
if 표현식에서 조건 결과가 참일 여부에 따라 분기 중 하나를 실행
## 스칼라 스타일
```javascript
val filename = if (!args.isEmpty) args(0) else "default.txt"
```
스칼라 if 표현식은 결과로 값을 내놓는다.

var 대신 val로 선언하면 좋은 점
* 변수가 사용되는 범위 내에서 값의 변화 여부를 판단하기 위해 모든 코드 살펴볼 필요 X
* 동일성 추론 : 해당 표현식에 사이드 이펙트가 존재하지 않기 때문에 값과 동일시하여 사용 가능

```javascript
// 예시
println(filename) → println(if (!args.isEmpty) args(0) else "default.txt")
```
# while 루프
* while과 do-while은 표현식이 아니라, loop라고 부름
* loop의 결과 타입은 Unit이다. 그래서 어느정도의 side effect가 발생할 수 있음
* Unit 타입에는 Unit value 밖에 없고, 이 값을 빈 괄호()로 표기


```javascript
// 최대 공약수 구하기
def gcdLoop(x: Long, y: Long): Long = {
    var a = x
    var b = y
    while (a != 0) {
        val temp = a
        a = b % a
        b = temp
    }
    b
}

// 결과
scala> gcdLoop(10, 20)
val res0: Long = 10
 
scala> gcdLoop(4, 6)
val res1: Long = 2
```


* ()은 값이 존재한다는 점에서 자바의 void와 다른 의미이다.
```javascript
scala> def greet() = { println("hi") }
def greet(): Unit
 
scala> () == greet()
hi
val res10: Boolean = true
```
greet는 결과 타입이 Unit인 프로시저라고 한다. 
(결과 값이 있으면 함수, 결과 값이 없으면 프로시저라고 부른다.)

* ()은 당연히 ()를 반환할 것이고, greet() 또한 Unit 함수이기 때문에 ()를 반환하므로 서로 동일하다.

* 다음과 같이 일반적인 형태로 while 루프를 스칼라에서 사용하면 문제가 생긴다.

```java
scala> while ((line = scala.io.StdIn.readLine()) != "")
     |   println("Read: " + line)
                                                 ^
       warning: comparing values of types Unit and String using `!=` will always yield true
Read: ddd
Read: ddd
Read:
Read:
```

* 위의 readLine 함수는 Unit 타입으로 정의되어 있다.
=> 결과 값은 ()일 것이고 해당 값은 빈 문자열인 ""와 같을 수 없을 것이다.

* 자바에서는 위와 관련된 I/O 함수가 실행되었을 때 line 이라는 변수에 값이 할당이 되겠지만 스칼라는 해당 함수가 Unit 타입이면 항상 ()를 반환한다. 


이를 해결 하기 위해서...
``` java
scala> while({line = scala.io.StdIn.readLine(); line != ""})
     |   println("Read: " + line)
```
# for 표현식

# for 표현식
여러가지 방법으로 조합해서 다양한 반복 작업을 처리할 수 있다.
연속적인 정수에 대해 작업을 처리하는 것도 간략하게 가능하며, 여러 종류 컬렉션을 대상으로 조건에 맞는 요소를 가려내고 새로운 컬렉션을 만들 수 있다.

### 컬렉션 이터레이션
```java
val filesHere = (new java.io.File(".")).listFiles
val filesHere: Array[java.io.File] = Array(.\fsc, .\fsc.bat, .\scala, .\scala.bat, .\scalac, .\scalac.bat, .\scaladoc, .\scaladoc.bat, .\scalap, .\scalap.bat)
 
 scala> for (file <- filesHere) {
     |   println(file)
     | }
.\fsc
.\fsc.bat
.\scala
.\scala.bat
.\scalac
.\scalac.bat
.\scaladoc
.\scaladoc.bat
.\scalap
.\scalap.bat
```
* 자바 API를 사용해서 디렉토리 내의 모든 파일을 출력하는 코드
* file <- filesHere 은 제너레이터(generator)라고 부른다. 각 단계마다 file 이라는 val 원소 값으로 초기화 한다.
* 컴파일러는 files가 Array[File] 타입이기 때문에 file의 타입도 File을 추론할 수 있다.

### 필터링
컬렉션 모든 원소 접근 않고 일부만 사용하고 싶은 경우, for 문에 if 사용 가능하다.
```java
var filesHere = (new java.io.File(".")).listFiles
var filesHere: Array[java.io.File] = Array(.\fsc, .\fsc.bat, .\scala, .\scala.bat, .\scalac, .\scalac.bat, .\scaladoc, .\scaladoc.bat, .\scalap, .\scalap.bat)
 
 
scala> for (file <- filesHere if file.getName.endsWith(".bat")) {
     |   println(file)
     | }
.\fsc.bat
.\scala.bat
.\scalac.bat
.\scaladoc.bat
.\scalap.bat
```
* 위 예제는 if 문을 활용해서 조건 별로 file들을 대상으로 명령 수행 가능
> for 표현식은 사용하기 위한 값을 결과로 내놓는다.
# try 표현식
# match 표현식
# break, continue 문 없이 살기
# 변수 스코프
# 명령형 스타일 코드 리펙토링
