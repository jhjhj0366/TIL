# if 표현식
## 명령형 언어 스타일
```java
var filename = "default.txt"
  if (!args.isEmpty)
    filename = args(0)
```
if 표현식에서 조건 결과가 참일 여부에 따라 분기 중 하나를 실행
## 스칼라 스타일
```javascript
val filename = if (!args.isEmpty) args(0) else "default.txt"
```
스칼라 if 표현식은 결과로 값을 내놓는다.

var 대신 val로 선언하면 좋은 점
* 변수가 사용되는 범위 내에서 값의 변화 여부를 판단하기 위해 모든 코드 살펴볼 필요 X
* 동일성 추론 : 해당 표현식에 사이드 이펙트가 존재하지 않기 때문에 값과 동일시하여 사용 가능

```javascript
// 예시
println(filename) → println(if (!args.isEmpty) args(0) else "default.txt")
```
# while 루프
* while과 do-while은 표현식이 아니라, loop라고 부름
* loop의 결과 타입은 Unit이다. 그래서 어느정도의 side effect가 발생할 수 있음
* Unit 타입에는 Unit value 밖에 없고, 이 값을 빈 괄호()로 표기
```java
// 최대 공약수 구하기
def gcdLoop(x: Long, y: Long): Long = {
    var a = x
    var b = y
    while (a != 0) {
        val temp = a
        a = b % a
        b = temp
    }
    b
}

// 결과
scala> gcdLoop(10, 20)
val res0: Long = 10
 
scala> gcdLoop(4, 6)
val res1: Long = 2
```


* ()은 값이 존재한다는 점에서 자바의 void와 다른 의미이다.
```java
scala> def greet() = { println("hi") }
def greet(): Unit
 
scala> () == greet()
hi
val res10: Boolean = true
```
greet는 결과 타입이 Unit인 프로시저라고 한다. 
(결과 값이 있으면 함수, 결과 값이 없으면 프로시저라고 부른다.)

* ()은 당연히 ()를 반환할 것이고, greet() 또한 Unit 함수이기 때문에 ()를 반환하므로 서로 동일하다.

* 다음과 같이 일반적인 형태로 while 루프를 스칼라에서 사용하면 문제가 생긴다.

```java
scala> while ((line = scala.io.StdIn.readLine()) != "")
     |   println("Read: " + line)
                                                 ^
       warning: comparing values of types Unit and String using `!=` will always yield true
Read: ddd
Read: ddd
Read:
Read:
```

* 위의 readLine 함수는 Unit 타입으로 정의되어 있다.
=> 결과 값은 ()일 것이고 해당 값은 빈 문자열인 ""와 같을 수 없을 것이다.

* 자바에서는 위와 관련된 I/O 함수가 실행되었을 때 line 이라는 변수에 값이 할당이 되겠지만 스칼라는 해당 함수가 Unit 타입이면 항상 ()를 반환한다. 


이를 해결 하기 위해서...
``` java
scala> while({line = scala.io.StdIn.readLine(); line != ""})
     |   println("Read: " + line)
```
# for 표현식
# try 표현식
# match 표현식
# break, continue 문 없이 살기
# 변수 스코프
# 명령형 스타일 코드 리펙토링
