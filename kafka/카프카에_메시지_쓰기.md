# 3.1 프로듀서 개요

프로듀서가 데이터가 데이터를 전송할 때 내부적으로 처리되는 단계는 다음과 같다.
      ![](https://images.velog.io/images/dev_jhjhj/post/bcb68189-b5dd-4ca0-abe3-d5857176cdbe/%E1%84%89%E1%85%B3%E1%84%8F%E1%85%B3%E1%84%85%E1%85%B5%E1%86%AB%E1%84%89%E1%85%A3%E1%86%BA%202021-08-24%20%E1%84%8B%E1%85%A9%E1%84%92%E1%85%AE%2011.05.29.png)  

* 1. 카프카에 쓰려는 메시지를 갖는 ProducerRecord를 생성 (전송할 토픽과 값을 포함, 선택적으로 Key 값과 파티션 지정 가능)

* 2. 메세지 객체들이 네트워크로 전송될 수 있도록 바이트 배열로 직렬화  진행, 직렬처리기(serializer)와 컴포넌트(클래스)가 처리

* 3. 해당 데이터는 파티셔너와 컴포넌트(클래스)에 전달

파티션 지정 않았다면, ProducerRecord의 키를 기준으로 파티셔너가 하나의 파티션 선택
파티션이 선택되면 해당 레코드(ProducerRecord 객체)의 메시지가 저장될 토픽과 파티션을 프로듀서가 알게됨
토픽과 파티션으로 전송될 레코드들을 모은 레코드 배치 추가, 별개의 스레드가 그 배치를 카프카 브로커에 전송
* 4. 브로커 수신된 메시지 처리 후 응답

성공 → RecodrMetadata 객체 반환(토픽, 파티션, 패티션 내부의 메시지 오프셋 제공)
실패 → 에러 반환 (에러 수신한 프로듀서는 메시지 쓰기 포기하고 에러 반환전에 몇번 더 재전송 시도 할 수 있음)


# 3.2 카프카 프로듀서 구성하기
* 카프카 프로듀서를 수행하는 객체는 ProducerRecord
* 카프카에 메시지를 쓰려면 ProducerRecord 객체를 먼저 생성
* ProducerRecord 은 세개의 필수 속성을 갖음 (이 외에도 원하는 속성 설정 가능)
	* bootstrap.server
     - 카프카 클러스터에 최초 연결을 위해 프로듀서가 사용하는 브로커들의 host:port 목록을 설정
	* key.serializer
    - 프로듀서가 생성하는 레코드(ProducerRecord 객체)의 메시지 키를 직렬화하기 위한 클래스 이름을 이 속성에 설정 (key 없이 값만 전송할 때도 key.serializer 설정 필요)
    - key.serializer에 설정하는 클래스는 "org.apache.kafka.common.serialization.Serializer" 인터페이스를 구현해야 
    - 카프카 클라이언트 패키지에는 다음과 같은 3가지 Serializer가 포함되어 있다.
ByteArraySerializer, StringSerializer,IntegerSerializer

따라서 많이 사용하는 타입들을 직렬화 할때는 따로 직렬처리기를 구현하지 않아도 됨
	* value.serializer
    - 레코드 메시지 값 직렬화 하는 데 사용되는 클래스 이름을 여기서 설정
    - 직렬화 방법은 key.serializer와 동일
    
```    
private Properties kafkaProps = new Properties ();		// 1. 카프카 Properties 객체 생성
kafkaProps.put("bootstrap.servers", "brokerl:9892,broker:9892");

kafkaProps.put("key.serializer", "org.apache.kafka.common.serialization.StringSerializer"); //  메세지 key와 value 모두 문자열 타입 사용으로 StringSerializer 사용
kafkaProps.put("value.serializer", "org.apache.kafka.common.serialization.StringSerializer"); 

Producer<String, String> producer = new KafkaProducer <String, String>(kafkaProps);		// 새로운 프로듀서 객체 생성, 메세지 key, value (예시는 String)을 설정하고 Properties 객체를 생성자 인자로 전달
```

자세한 설정 참조 :  http://kafka.apache.org/documentation.html#producerconfigs



메세지 전송 방법에는 3가지
* Fire-and-forget(전송 후 망각)
     - send() 메서드로 메시지 전송만 (성공 여부 후속 조치 X)
     - 전송 실패할 경우, 프로듀서가 자동으로 재전송 시도
     - but, 메시지 유실 가능성 있음
     
     
* Synchronous send(동기식 전송)
     - send() 메서드로 메시지 전송하면 Java의 Future 객체 반환 → Future 객체의 get() 메소드 호출 후, 작업 완료 대기 → 브로커로부터 처리결과 반환
    
* Asynchronous send(비동기식 전송)
     - send() 메서드 호출할 때, callback 메서드를 구현한 객체를 매개변수로 전달(뒤에 설명)
     - 이 객체가 구현된 콜백 메서드는 카프카 브로커로부터 응답을 받을 때 자동 호출 →send()가 성공적으로 수행되었는지 확인 가능


## 3.3.1 동기식으로 메시지 전송하기
```
ProducerRecord<String, String> record = new ProducerRecord<>("CustomerCountury", "Precision Products", "France");
 
try {
    producer.send(record).get();        // step 1
} catch (Exception e){
    e.printStackTrace();        // step 2
}
```
* step 1
	- Future 객체의 get() 메서드를 사용해서 카프카 응답을 대기
	- ProducerRecord 객체가 전송 성공 시, RecodeMetadata 를 받게 되고, 이 객체를 사용해서 카프카에 쓴 메시지의 오프셋 (offset)을 알 수 있다.
	- ProducerRecord 객체가 전송 실패하면 예외 처리 발생

* step2
	- 예외 처리
    - 카프카 메시지 전송 전 에러
    - 전송 중 카프카 브로커가 전송 재시도 불가능 에러
    - 사용 가능한 전송 재시도 횟수 전부 소진

* 카프카 프로듀서 사용할 때 발생하는 에러
	- 재시도 가능(retriable) 에러
	- 연결 에러 : 다시 연결을 시도하여 성공하면 해결 됨
	- no lea	der(리더 없음) 에러 : 해당 파티션의 새로운 리더가 선출되면 해결 됨
재시도 불가능한 에러
	- 메세지가 너무 클 때 : 카프카 프로듀서는 재시도 않고 즉시 예외 반환
    
